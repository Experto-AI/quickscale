# Contributing Guidelines

This document outlines the coding standards and guidelines for contributing to this project.
This document is written for humans but also for AI coding assistants like GitHub Copilot, Cursor, and Windsurf.

## Table of Contents
- [ACT - Implementation Stage](docs/contrib/ACT.md)
    - Implementation Principles
      - Apply SOLID Principles During Implementation
        - Single Responsibility Principle (SRP)
        - Open/Closed Principle (OCP)
        - Dependency Inversion Principle (DIP)
      - Apply DRY (Don't Repeat Yourself)
      - Apply KISS (Keep It Simple, Stupid)
      - Apply Explicit Failure
    - Code Structure and Organization
      - Create Functions That Perform Only One Specific Task
      - Group Related Functionality Logically Within Distinct Modules and Files
      - Use Exceptions for Error Handling
    - Code Style and Consistency
      - Apply Clear and Consistent Naming Conventions
      - Use Specific Type Hints
      - Use Modern F-Strings
      - Structure Imports Logically
    - Testing During Implementation
      - Follow [Testing Standards](docs/contrib/shared/testing_standards.md) for contamination prevention
      - Apply strict test isolation and cleanup practices
      - When a test fails after code changes:
        - Always perform root cause analysis to determine if the test or the code is at fault
        - If the test reflects current, intended behavior, fix the code
        - If the test is outdated due to changed requirements, update the test
        - Never update a test just to make it pass—always confirm whether the test or the code is correct
        - Always document your reasoning and the root cause for updating either the test or the code
    - Documentation During Implementation
      - Write Clear, Concise Docstrings
      - Document Only Functionality, Not Arguments or Returns
      - Focus on "Why" Rather Than "What" in Comments
    - Logging and Debugging
      - Use Structured Logging Instead of Print Statements
    - Architecture Compliance
      - Follow Project Architecture
    - Focus and Scope Management
      - Implement Changes Incrementally with Minimal Impact
      - Preserve Existing Interfaces and Ensure Backward Compatibility
      - Match Existing Code Style and Patterns Precisely
    - Implementation Checklist
    - Next Steps
- [DEBUG - Debugging and Problem Resolution Stage](docs/contrib/DEBUG.md)
    - Systematic Debugging Approach
      - Apply Root Cause Analysis
        - Systematically Investigate to Identify and Fix the Fundamental Root Cause of Issues
      - Test Failures After Codebase Changes
        - When a test fails after codebase changes, always perform root cause analysis to determine if the test or the code is at fault
        - If the test reflects current, intended behavior, fix the code
        - If the test is outdated due to changed requirements, update the test
        - Never update a test just to make it pass—always confirm whether the test or the code is correct
        - Always document your reasoning and the root cause for updating either the test or the code
    - DMAIC Process for Structured Debugging
      - Define: Clearly Define the Problem with Specific Symptoms and Success Criteria
      - Measure: Gather Quantitative Data and Create Reproducible Test Cases
      - Analyze: Systematically Analyze Data to Identify the Precise Root Cause
      - Improve: Implement a Solution Addressing the Root Cause and Validate It
      - Control: Prevent Regression with Tests, Monitoring, and Documentation Updates
    - Systematic Debugging with Logging and Tools
      - Utilize Structured Logging and Debugging Tools for Systematic Problem Investigation
      - Avoid Ad-Hoc Debugging
    - Bug Fixing Methodology
      - Understand the Root Cause
        - Implement Proper Transaction Handling and Validation to Fix Concurrency Issues
        - Never Implement Superficial Fixes That Mask Underlying Problems
      - Minimize Code Changes
      - Add Regression Tests
      - Document the Fix
    - Focused Debugging Approach
      - Fix Only the Specific Reported Bug Without Additional Changes
      - Avoid Over-Engineering Fixes
    - Debugging Application by Stage
      - Planning Stage
      - Implementation Stage
      - Quality Control Stage
    - Debugging Checklist
      - Root Cause Analysis
      - Systematic Approach
      - Bug Fixing
      - Focus and Scope
    - Next Steps
- [PLAN - Planning and Analysis Stage](docs/contrib/PLAN.md)
    - Role Definition and Expertise
      - You are a **Python master**, a highly experienced **tutor**, a world-renowned **Django Full Stack Engineer**.
    - Understanding the Project and Codebase
      - Reference Documentation Sources
      - Study Existing Architecture and Patterns
    - Planning Principles
      - Apply KISS (Keep It Simple, Stupid) During Planning
      - Plan with SOLID Principles in Mind
      - Plan for DRY (Don't Repeat Yourself)
      - Plan for Explicit Failure
    - Task Analysis and Planning
      - Understand User Intent and Requirements
      - Plan Implementation Steps
      - Plan for Architecture Compliance
      - Plan for Testability
    - Scope and Task Boundary Planning
      - Define Clear Task Boundaries
      - Plan for Focused Implementation
      - Plan for Incremental Changes
    - Documentation Planning
      - Plan Documentation Needs
    - Quality Planning
      - Plan for Quality Assurance
    - Planning Checklist
    - Next Steps
- [QUALITY - Quality Control Stage](docs/contrib/QUALITY.md)
    - Quality Control Principles
      - Verify Adherence to Technical Stack and Architecture
        - Check Technical Stack Compliance
        - Verify Architectural Pattern Compliance
    - Code Quality Validation
      - Verify SOLID Principles Compliance
        - Check Single Responsibility Principle
        - Check Open/Closed Principle
        - Check Dependency Inversion Principle
      - Verify DRY Principle Compliance
      - Verify KISS Principle Compliance
      - Verify Explicit Failure Compliance
    - Testing Quality Assurance
      - Verify Implementation-First Testing Approach
      - Verify Test Structure and Organization
      - Verify Behavior-Focused Testing
      - Verify Mock Usage for Isolation
      - Verify Test Coverage
    - Documentation Quality Assurance
      - Verify Code Documentation Standards
      - Verify Documentation Completeness
    - Code Style Quality Assurance
      - Verify Naming Conventions
      - Verify Type Hints Usage
      - Verify String Formatting
      - Verify Import Organization
    - Focus and Scope Validation
      - Verify Task Boundary Compliance
      - Verify Interface Preservation
      - Verify Code Style Consistency
    - Quality Control Checklist
      - Architecture and Technical Stack
      - Code Principles
      - Testing Quality
      - Documentation Quality
      - Code Style Quality
      - Focus and Scope
    - Quality Control Process
      - 1. Self-Review
      - 2. Test Execution
      - 3. Documentation Review
      - 4. Architecture Review
      - 5. Final Validation
    - Next Steps

