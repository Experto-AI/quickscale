"""
Tests for Sprint 24: Zero-Cost AI Services Implementation.

These tests verify that the zero-cost service implementation works correctly
across all components: model validation, service creation, credit consumption.

Note: These tests check the template files generated by QuickScale, not a running Django project.
"""

import unittest
import tempfile
import shutil
from pathlib import Path
from decimal import Decimal
from unittest.mock import patch, MagicMock, mock_open

# Import QuickScale modules
from quickscale.commands.service_generator_commands import ServiceGeneratorCommand
from quickscale.commands.command_manager import CommandManager


class TestZeroCostServiceTemplateValidation(unittest.TestCase):
    """Test cases for validating zero-cost service templates."""
    
    def setUp(self):
        """Set up test environment."""
        self.base_path = Path(__file__).parent.parent.parent.parent
    
    def test_service_model_template_allows_zero_cost(self):
        """Test that Service model template allows 0.0 credit cost."""
        credits_models_path = self.base_path / 'quickscale' / 'project_templates' / 'credits' / 'models.py'
        
        with open(credits_models_path, 'r') as f:
            models_content = f.read()
        
        # Should allow MinValueValidator(Decimal('0.0'))
        self.assertIn("MinValueValidator(Decimal('0.0'))", models_content,
                     "Service model template does not allow zero credit cost")
        
        # Should have updated help text
        self.assertIn("0.0 for free services", models_content,
                     "Service model template help text does not mention free services")
        
        # Should have updated __str__ method for free services
        self.assertIn("if credit_cost == 0:", models_content,
                     "Service model template __str__ method does not handle zero cost")
    
    def test_service_model_template_validation_logic(self):
        """Test that Service model template has proper validation logic."""
        credits_models_path = self.base_path / 'quickscale' / 'project_templates' / 'credits' / 'models.py'
        
        with open(credits_models_path, 'r') as f:
            models_content = f.read()
        
        # Should still prevent negative costs
        self.assertIn("MinValueValidator", models_content,
                     "Service model template does not have minimum value validation")
        
        # Should have appropriate field definition
        self.assertIn("credit_cost = models.DecimalField", models_content,
                     "Service model template does not have credit_cost field")
        
        # Should have proper decimal configuration
        self.assertIn("decimal_places=2", models_content,
                     "Service model template does not have proper decimal places")
    
    def test_service_model_template_string_representation(self):
        """Test that Service model template has proper string representation."""
        credits_models_path = self.base_path / 'quickscale' / 'project_templates' / 'credits' / 'models.py'
        
        with open(credits_models_path, 'r') as f:
            models_content = f.read()
        
        # Should have __str__ method
        self.assertIn("def __str__(self):", models_content,
                     "Service model template does not have __str__ method")
        
        # Should handle free services in __str__
        self.assertIn('return f"{name} (Free)"', models_content,
                     "Service model template __str__ method does not handle free services")
        
        # Should handle paid services in __str__
        self.assertIn('return f"{name} ({credit_cost} credits)"', models_content,
                     "Service model template __str__ method does not handle paid services")


class TestZeroCostServiceBaseTemplate(unittest.TestCase):
    """Test cases for BaseService template with zero-cost services."""
    
    def setUp(self):
        """Set up test environment."""
        self.base_path = Path(__file__).parent.parent.parent.parent
    
    def test_base_service_template_handles_zero_cost(self):
        """Test that BaseService template handles zero-cost services."""
        base_service_path = self.base_path / 'quickscale' / 'project_templates' / 'services' / 'base.py'
        
        with open(base_service_path, 'r') as f:
            base_content = f.read()
        
        # Should handle zero-cost services
        self.assertIn("if service.credit_cost == 0:", base_content,
                     "BaseService template does not handle zero-cost services")
        
        # Should create zero-amount transaction for tracking
        self.assertIn("amount=Decimal('0')", base_content,
                     "BaseService template does not create zero-amount transaction")
        
        # Should have appropriate description for free services
        self.assertIn("(free)", base_content,
                     "BaseService template description does not mention free services")
    
    def test_base_service_template_credit_consumption(self):
        """Test that BaseService template has proper credit consumption logic."""
        base_service_path = self.base_path / 'quickscale' / 'project_templates' / 'services' / 'base.py'
        
        with open(base_service_path, 'r') as f:
            base_content = f.read()
        
        # Should use priority credit consumption
        self.assertIn("consume_credits_with_priority", base_content,
                     "BaseService template does not use priority credit consumption")
        
        # Should create ServiceUsage records
        self.assertIn("ServiceUsage.objects.create", base_content,
                     "BaseService template does not create ServiceUsage records")
        
        # Should have proper user validation
        self.assertIn("if not isinstance(user, User):", base_content,
                     "BaseService template does not validate user")


class TestZeroCostServiceCLI(unittest.TestCase):
    """Test cases for CLI commands with zero-cost services."""
    
    def setUp(self):
        """Set up test environment."""
        self.test_dir = tempfile.mkdtemp()
        self.command = ServiceGeneratorCommand()
        
    def tearDown(self):
        """Clean up test environment."""
        shutil.rmtree(self.test_dir)
    
    @patch('quickscale.commands.service_generator_commands.MessageManager')
    def test_service_generator_with_free_flag(self, mock_message):
        """Test service generator with --free flag."""
        # Mock file operations
        with patch('builtins.open', mock_open()) as mock_file:
            with patch('pathlib.Path.exists', return_value=False):
                with patch('pathlib.Path.mkdir'):
                    # Mock the database configuration to avoid actual DB calls
                    with patch.object(self.command, '_configure_service_in_database') as mock_config:
                        mock_config.return_value = {"success": True}
                        
                        # Execute with free flag
                        result = self.command.execute(
                            service_name='free_test_service',
                            service_type='basic',
                            output_dir=self.test_dir,
                            free=True,
                            description='Free test service'
                        )
                        
                        # Verify credit cost is set to 0.0
                        self.assertEqual(result['credit_cost'], 0.0)
                        self.assertTrue(result['success'])
                        
                        # Verify database configuration was called with correct parameters
                        mock_config.assert_called_once_with(
                            'free_test_service',
                            'Free test service',
                            0.0
                        )
    
    @patch('quickscale.commands.service_generator_commands.MessageManager')
    def test_service_generator_free_overrides_credit_cost(self, mock_message):
        """Test that --free flag overrides --credit-cost."""
        # Mock file operations
        with patch('builtins.open', mock_open()) as mock_file:
            with patch('pathlib.Path.exists', return_value=False):
                with patch('pathlib.Path.mkdir'):
                    with patch.object(self.command, '_configure_service_in_database') as mock_config:
                        mock_config.return_value = {"success": True}
                        
                        # Execute with both free flag and credit cost
                        result = self.command.execute(
                            service_name='test_service',
                            service_type='basic',
                            output_dir=self.test_dir,
                            credit_cost=5.0,  # This should be overridden
                            free=True,
                            description='Test service'
                        )
                        
                        # Verify free flag overrides credit cost
                        self.assertEqual(result['credit_cost'], 0.0)
                        
                        # Verify database configuration was called with 0.0
                        mock_config.assert_called_once_with(
                            'test_service',
                            'Test service',
                            0.0
                        )


class TestZeroCostServiceFileValidation(unittest.TestCase):
    """Test cases for verifying file content includes zero-cost service support."""
    
    def setUp(self):
        """Set up test environment."""
        self.base_path = Path(__file__).parent.parent.parent.parent
    
    def test_service_model_zero_cost_field_validation(self):
        """Test that service model zero cost field validation works."""
        pass  # Placeholder for service model zero cost field validation test
    
    def test_cli_supports_free_flag(self):
        """Test that CLI supports --free flag for generate-service command."""
        cli_path = self.base_path / 'quickscale' / 'cli.py'
        
        if cli_path.exists():
            with open(cli_path, 'r') as f:
                cli_content = f.read()
            
            # Should have --free argument
            self.assertIn("--free", cli_content)
            
            # Should have help text for free flag
            self.assertIn("Generate a free service", cli_content)


class TestZeroCostServiceGenerator(unittest.TestCase):
    """Test cases for service generator with zero-cost services."""
    
    def setUp(self):
        """Set up test environment."""
        self.test_dir = tempfile.mkdtemp()
        self.command = ServiceGeneratorCommand()
        self.base_path = Path(__file__).parent.parent.parent.parent
        
    def tearDown(self):
        """Clean up test environment."""
        shutil.rmtree(self.test_dir)
    
    def test_service_generator_free_flag_sets_zero_cost(self):
        """Test that --free flag sets credit cost to 0.0."""
        # Mock file operations
        with patch('builtins.open', mock_open()) as mock_file:
            with patch('pathlib.Path.exists', return_value=False):
                with patch('pathlib.Path.mkdir'):
                    with patch.object(self.command, '_configure_service_in_database') as mock_config:
                        mock_config.return_value = {"success": True}
                        
                        # Execute with free flag
                        result = self.command.execute(
                            service_name='free_test_service',
                            service_type='basic',
                            output_dir=self.test_dir,
                            free=True,
                            description='Free test service'
                        )
                        
                        # Verify credit cost is set to 0.0
                        self.assertEqual(result['credit_cost'], 0.0)
                        self.assertTrue(result['success'])
                        
                        # Verify database configuration was called with correct parameters
                        mock_config.assert_called_once_with(
                            'free_test_service',
                            'Free test service',
                            0.0
                        )
    
    def test_service_generator_without_free_flag(self):
        """Test that service generator works normally without --free flag."""
        with patch('builtins.open', mock_open()) as mock_file:
            with patch('pathlib.Path.exists', return_value=False):
                with patch('pathlib.Path.mkdir'):
                    with patch.object(self.command, '_configure_service_in_database') as mock_config:
                        mock_config.return_value = {"success": True}
                        
                        # Execute without free flag
                        result = self.command.execute(
                            service_name='paid_service',
                            service_type='basic',
                            output_dir=self.test_dir,
                            credit_cost=2.0,
                            description='Paid service'
                        )
                        
                        # Verify credit cost is preserved
                        self.assertEqual(result['credit_cost'], 2.0)
                        self.assertTrue(result['success'])
                        
                        # Verify database configuration was called with correct parameters
                        mock_config.assert_called_once_with(
                            'paid_service',
                            'Paid service',
                            2.0
                        )

    @patch('os.path.exists')
    @patch('subprocess.run')
    def test_configure_service_in_database_uses_free_flag(self, mock_subprocess, mock_exists):
        """Test that _configure_service_in_database uses free flag correctly."""
        # Mock that manage.py exists 
        mock_exists.return_value = True
        
        # Mock two subprocess calls: first for docker compose ps, second for management command
        mock_subprocess.side_effect = [
            # First call: docker compose ps
            MagicMock(returncode=0, stdout='service_id\n'),
            # Second call: management command
            MagicMock(returncode=0, stdout='{"success": true}')
        ]
        
        # Test with free flag
        result = self.command._configure_service_in_database(
            'free_service',
            'Free service description',
            0.0
        )
        
        # Verify result
        self.assertTrue(result.get('success', False))
        
        # Verify subprocess was called twice
        self.assertEqual(mock_subprocess.call_count, 2)
        
        # Check the second call (management command) contains --free flag
        second_call_args = mock_subprocess.call_args_list[1][0][0]
        self.assertIn('--free', second_call_args)

    @patch('os.path.exists')
    @patch('subprocess.run')
    def test_configure_service_in_database_uses_credit_cost(self, mock_subprocess, mock_exists):
        """Test that _configure_service_in_database uses credit cost correctly."""
        # Mock that manage.py exists 
        mock_exists.return_value = True
        
        # Mock two subprocess calls: first for docker compose ps, second for management command
        mock_subprocess.side_effect = [
            # First call: docker compose ps
            MagicMock(returncode=0, stdout='service_id\n'),
            # Second call: management command
            MagicMock(returncode=0, stdout='{"success": true}')
        ]
        
        # Test with regular credit cost
        result = self.command._configure_service_in_database(
            'paid_service',
            'Paid service description', 
            2.5
        )
        
        # Verify result
        self.assertTrue(result.get('success', False))
        
        # Verify subprocess was called twice
        self.assertEqual(mock_subprocess.call_count, 2)
        
        # Check the second call (management command) contains credit cost
        second_call_args = mock_subprocess.call_args_list[1][0][0]
        self.assertIn('2.5', ' '.join(second_call_args))

    def test_command_manager_generate_service_with_free_flag(self):
        """Test that CommandManager supports generate-service with --free flag."""
        command_manager = CommandManager()
        
        # Mock execute_command to verify it receives the free flag
        with patch.object(command_manager, 'execute_command') as mock_execute:
            mock_execute.return_value = {"success": True, "credit_cost": 0.0}
            
            # Should be able to call with free flag
            result = command_manager.execute_command(
                'generate-service',
                service_name='test_free_service',
                free=True
            )
            
            # Verify it was called with the correct parameters
            mock_execute.assert_called_once_with(
                'generate-service',
                service_name='test_free_service',
                free=True
            )

    def test_validate_service_name_with_free_services(self):
        """Test that service name validation works with free services."""
        # Test valid service names
        valid_names = ['free_service', 'zero_cost_ai', 'no_cost_service']
        
        for name in valid_names:
            with patch.object(self.command, '_validate_service_name') as mock_validate:
                mock_validate.return_value = True
                
                result = self.command._validate_service_name(name)
                self.assertTrue(result)

    def test_to_class_name_with_free_services(self):
        """Test that _to_class_name works correctly with free service names."""
        test_cases = [
            ('free_service', 'FreeService'),
            ('zero_cost_ai', 'ZeroCostAi'),
            ('no_cost_service', 'NoCostService')
        ]
        
        for service_name, expected_class_name in test_cases:
            with patch.object(self.command, '_to_class_name') as mock_to_class:
                mock_to_class.return_value = expected_class_name
                
                result = self.command._to_class_name(service_name)
                self.assertEqual(result, expected_class_name)

    def test_service_model_allows_zero_cost_generator(self):
        """Test that Service model allows zero cost (from generator perspective)."""
        # This test validates that the generator can create services with 0.0 cost
        with patch('builtins.open', mock_open()) as mock_file:
            with patch('pathlib.Path.exists', return_value=False):
                with patch('pathlib.Path.mkdir'):
                    with patch.object(self.command, '_configure_service_in_database') as mock_config:
                        mock_config.return_value = {"success": True}
                        
                        # Should be able to create a service with 0.0 cost
                        result = self.command.execute(
                            service_name='zero_cost_test',
                            service_type='basic',
                            output_dir=self.test_dir,
                            credit_cost=0.0,
                            description='Zero cost test service'
                        )
                        
                        self.assertEqual(result['credit_cost'], 0.0)
                        self.assertTrue(result['success'])


if __name__ == '__main__':
    unittest.main()